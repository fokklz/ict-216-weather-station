#include "arduino_secrets.h"

// include m5stack library
#include <M5Stack.h>
// include m5stack env library
#include "M5_ENV.h"
// include adafruit neopixel library for led control
#include <Adafruit_NeoPixel.h>
// include math library for math functions
#include <math.h>
// include string library for string functions
#include <string.h>

/**
   External helping sources:
   https://github.com/m5stack/M5Stack/blob/master/examples/Fire/RGB_BAR_TEST/RGB_BAR_TEST.ino
   https://github.com/m5stack/M5Stack/blob/master/examples/Unit/RGB_SK6812/RGB_SK6812.ino
   https://github.com/m5stack/M5Unit-ENV/blob/master/examples/Unit_ENVIII_M5Core/Unit_ENVIII_M5Core.ino
*/

#define M5STACK_FIRE_NEO_NUM_LEDS 10
#define M5STACK_FIRE_NEO_DATA_PIN 15

#define PIN       26  //定义NeoPixel的控制引脚
#define NUMPIXELS 3   //定义NeoPixel控制灯灯数量

// initialize side lights
Adafruit_NeoPixel unit_core = Adafruit_NeoPixel(M5STACK_FIRE_NEO_NUM_LEDS, M5STACK_FIRE_NEO_DATA_PIN, NEO_GRB + NEO_KHZ800);

// initialize RGB unit
Adafruit_NeoPixel unit_rgb = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);

// unit: ENV - declarations
SHT3X sht30;
QMP6988 qmp6988;

/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/f444c48c-f939-40e1-bd0e-417bef1cf49d

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float hpa;
  float hum;
  float tmp;
  int hpa_scale;
  bool enableLED;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

/**
   Global variable declaration
*/

// screen dimensions
int screen_size_x = 320;
int screen_size_y = 240;

// size of a "block"
// used for ui creation
float unit_y = screen_size_y / 2;
float unit_x = ((screen_size_x / 2) / 3) * 2.5;

// pin mapping
// allows to modify left and right LEDs on the same hight at the same time
int light_core_pins[5][2] = {
  {0, 9},
  {1, 8},
  {2, 7},
  {3, 6},
  {4, 5}
};

// create initial light states
uint32_t lights[5] = {
  unit_core.Color(0, 0, 0),
  unit_core.Color(0, 0, 0),
  unit_core.Color(0, 0, 0),
  unit_core.Color(0, 0, 0),
  unit_core.Color(0, 0, 0)
};

// track display state
bool displayEnabled = true;

// current loop iteration
// used to determine when to update the lights
int loopi = 0;

/**
   Mode Handling
   variables and functions related to mode switching
*/

// mode presets
int mode[6] = {1, 5, 60, 120, 240, 3600};
int currentMode = 0;

// count current mode one up
// reset to 0 if bigger than array
void switchMode() {
  currentMode++;
  if (currentMode >= 6) {
    currentMode = 0;
  }
}

// get currently active mode value
int getMode() {
  return mode[currentMode];
}

// allows to print text centered
void displayCenteredText(int x, int y, char* text) {
  // Get the width of the text
  int textWidth = M5.Lcd.textWidth(text);

  // Calculate the x position to center the text
  int xPos = x - (textWidth / 2);

  // Display the text centered at the target x and y position
  M5.Lcd.setCursor(xPos, y);
  M5.Lcd.println(text);
}

// converts seconds to a readable time string
char *readable_time(int seconds) {
  int minutes = seconds / 60;
  int hours = minutes / 60;
  int days = hours / 24;

  minutes = minutes % 60;
  hours = hours % 24;
  seconds = seconds % 60;

  // create a string
  char *time_string = (char *)malloc(100 * sizeof(char));
  memset(time_string, 0, 100);

  // formated output
  if (days > 0) {
    sprintf(time_string, "%d DAY%s", days, (days > 1) ? "S" : "");
  } else if (hours > 0) {
    sprintf(time_string, "%d HOUR%s", hours, (hours > 1) ? "S" : "");
  } else if (minutes > 0) {
    sprintf(time_string, "%d MIN%s", minutes, (minutes > 1) ? "S" : "");
  } else {
    sprintf(time_string, "%d SEC%s", seconds, (seconds > 1) ? "S" : "");
  }

  return time_string;
}

// draws the basic interface
void drawUI() {
  /**

     Create UI
     ------------------
     |      temp      |
     |     celsius    |
     ------------------
     | hum | pressure |
     |  %  |    hPa   |
     ------------------
     |      menu      |
     ------------------

  */
  // draw a border around the screen
  int thickness = 3;
  for (int i = 0; i < thickness; i++) {
    M5.Lcd.drawRect(i, i, screen_size_x - (i * 2), screen_size_y - (i * 2), TFT_WHITE);
  }
  // draw middle horizontal divider
  M5.Lcd.drawLine(0, unit_y, M5.Lcd.width(), unit_y, TFT_WHITE);
  // draw lower center vertical divider
  M5.Lcd.drawLine(unit_x, unit_y, unit_x, M5.Lcd.height(), TFT_WHITE);

  // menu background
  M5.Lcd.fillRect(0, screen_size_y - 30, screen_size_x, 30, WHITE);

  // menu text style
  M5.Lcd.setTextSize(2);
  M5.Lcd.setTextColor(BLACK, WHITE);

  // write menu texts
  displayCenteredText((screen_size_x / 6) * 1 + 13, screen_size_y - 20, "SCREEN");
  displayCenteredText((screen_size_x / 6) * 3, screen_size_y - 20, "  LED  ");
  displayCenteredText((screen_size_x / 6) * 5 - 13, screen_size_y - 20, readable_time(getMode()));
}

// store new sensor data
void updateData() {
  // update pressure value
  hpa = round(qmp6988.calcPressure() / 100);
  hpa_scale = hpaScale(hpa);

  // Obtain the data of shT30
  if (sht30.get() == 0) {
    tmp = round(sht30.cTemp * 10) / 10;
    hum = sht30.humidity;
  } else {
    // defaults while not receiving data
    tmp = 0, hum = 0;
  }
}

// called on device startup
void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // initialize M5
  M5.begin();
  // initialize Power
  M5.Power.begin();

  // initialize lights
  unit_core.begin();
  unit_rgb.begin();

  // initialize wireing
  Wire.begin();
  // initialize env
  qmp6988.init();
}

// send the updates to the hardware
void updateLights() {
  if (!enableLED) {
    // Clear LED
    unit_rgb.clear();
    unit_core.clear();
  }

  // Update LED
  unit_rgb.show();
  unit_core.show();
}

// convert pressure to a scale from 1-10
int hpaScale(float hpa_value) {
  // Define the range of HPA values that will correspond to the 1-10 scale
  float min_hpa = 950.0;
  float max_hpa = 1030.0;

  // Normalize the HPA value to fall within the defined range
  float normalized_hpa = fmax(fmin(hpa_value, max_hpa), min_hpa);

  // Scale the normalized HPA value to the 1-10 range
  int scale_value = round((normalized_hpa - min_hpa) * 10.0 / (max_hpa - min_hpa) + 1.0);

  return scale_value;
}

// main application loop
void loop() {
  ArduinoCloud.update();

  drawUI();
  updateData();
  
  // set display text
  int temp_x = 20;
  int temp_y = 20;

  // text style
  M5.Lcd.setTextColor(WHITE, BLACK);
  M5.Lcd.setTextSize(3);

  // Ouput temp upper half
  M5.lcd.setCursor(temp_x, 20);
  M5.Lcd.printf("Temperature");
  M5.Lcd.setTextSize(5);
  M5.lcd.setCursor(temp_x, (unit_y / 2));
  M5.Lcd.printf("%2.1f", tmp);

  /**
     Celcius icon
     Workaround due to not existing in default ascii set
  */
  // get tmp size + some extra space
  int degOffset = 123;
  M5.lcd.setCursor(temp_x + degOffset, (unit_y / 2) - 5);
  M5.Lcd.setTextSize(3);
  M5.Lcd.printf("o");
  M5.lcd.setCursor(temp_x + degOffset + 18, (unit_y / 2));
  M5.Lcd.setTextSize(5);
  M5.Lcd.printf("C");

  // Ouput humidity lower left
  M5.Lcd.setTextSize(2);
  M5.Lcd.setCursor(temp_x, unit_y + temp_y);
  M5.Lcd.printf("Humidity");
  M5.Lcd.setTextSize(4);
  M5.lcd.setCursor(temp_x, unit_y + temp_y + 30);
  M5.Lcd.printf("%2.0f%%", hum);

  // Ouput pressure lower right
  M5.Lcd.setTextSize(2);
  M5.Lcd.setCursor(unit_x + temp_x, unit_y + temp_y);
  M5.Lcd.printf("Pressure");
  M5.Lcd.setTextSize(4);
  M5.lcd.setCursor(unit_x + temp_x, unit_y + temp_y + 30);
  M5.Lcd.printf("%2.0fhPa", hpa);

  // generate new color values based on temperature
  int r = 0;
  int g = 0;
  int b = 0;
  if (tmp >= 26) {
    r = 255;
    g = 0;
    b = 0;
  } else if (tmp >= 18) {
    r = 0;
    g = 255;
    b = 0;
  } else {
    r = 0;
    g = 0;
    b = 255;
  }

  /**
    update color settings for LEDs
    */

  // RGB-Unit: first LED
  unit_rgb.setPixelColor(0, unit_rgb.Color(r, g, b));
  // RGB-Unit: secound LED
  unit_rgb.setPixelColor(1, unit_rgb.Color(r, g, b));
  // RGB-Unit: third LED
  unit_rgb.setPixelColor(2, unit_rgb.Color(r, g, b));
  // Side Lights: Top -> Down
  for (int i = 0; i < 5; i++) {
    unit_core.setPixelColor(light_core_pins[i][0], lights[i]);
    unit_core.setPixelColor(light_core_pins[i][1], lights[i]);
  }

  // Update lights based on mode
  if (loopi >= getMode() * 10) {
    // update color array / move all items one up - insert at 0
    for (int i = 5 - 1; i > 0; i--) {
      lights[i] = lights[i - 1];
    }
    lights[0] = unit_core.Color(r, g, b);

    // reset iteration counter
    loopi = 0;
  } else {
    // increment iteration counter
    loopi++;
  }

  // Button A: Toggle display
  if (M5.BtnA.wasPressed()) {
    displayEnabled = !displayEnabled;
    if (displayEnabled) {
      M5.Lcd.setBrightness(0);
    } else {
      M5.Lcd.setBrightness(255);
    }
  }
  // Button B: Toggle LED
  if (M5.BtnB.wasPressed()) {
    enableLED = !enableLED;
    // no update needed since 'onEnableLEDChange' will be called
  }
  // Button C: Switch mode
  if (M5.BtnC.wasPressed()) {
    switchMode();
  }
  // update m5 data
  M5.update();
  // update lights
  updateLights();
  // delay loop
  delay(100);
}


/*
  Since EnableLED is READ_WRITE variable, onEnableLEDChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onEnableLEDChange()  {
  updateLights();
}

